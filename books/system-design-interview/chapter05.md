# 5장 - 안정 해시 설계 
---

**수평적 규모 확장성을 위해선 데이터를 서버에 균등 분배**하는것이 중요  

따라서 **해시를 왜 쓰는지, 어떻게 안정 설계하는지 다룰 예정**

---

## 해시(Hash)란? 

정의 : 값을 고정된 길이의 데이터로 변환하는 함수나 그 결과값  

**예시)**
| 입력값     | 해시값 (출력)                           |
| ------- | ---------------------------------- |
| "hello" | `5d41402abc4b2a76b9719d911017c592` |
| "Hello" | `8b1a9953c4611296a827abf8c47804d7` |

  
**특징**  
1. 입력값의 길이는 중요하지 않음  
2. 출력값은 항상 같은 길이의 고정 값  
3. 대표적 해시함수 MD5, SHA-1, SHA-256, SHA-512

   
**(주요 특징)**  
| 특징           | 설명                      |
| ------------ | ----------------------- |
| **단방향성**     | 해시값만 보고 원본을 알 수 없음      |
| **충돌 최소화**   | 서로 다른 입력은 다른 해시값을 가져야 함 |
| **빠른 계산 속도** | 어떤 입력이든 빠르게 해시 가능       |
| **결정론적**     | 입력이 같으면 해시값도 항상 같음      |


    
--- 


  
## 해시(Hash)가 만들어진 목적
> 빠르고 쉽게 안전하게 비교하기 위해서

**주요 용도**
| 용도                | 설명                         |
| ----------------- | -------------------------- |
| **1. 데이터 무결성 검증** | 파일 다운로드 시 해시값 비교로 변조 여부 확인 |
| **2. 비밀번호 저장**    | 사용자 비밀번호를 평문이 아닌 해시값으로 저장  |
| **3. 빠른 검색 / 매핑** | 해시맵, 해시테이블 구조로 빠르게 값 찾기    |
| **4. 블록체인**       | 각 블록의 고유 ID, 연결 관계를 해시로 관리 |
| **5. 디지털 서명**     | 메시지를 고정된 크기의 해시로 바꾸고 서명    |


---
## 해시 기반 분산 전략

---
## `% N` 방식  

이중화 Cache 서버에서 해시로 내 Cache 서버를 찾아가자~  

[수식]
```
**유저의 Cache서버 index** = hash(key) % N (서버 갯수)
```

이 `% N` 방식의 문제는 
서버 갯수가 고정이면 문제가 안되지만 서버 갯수가 3대였는데 갑자기 4대로 늘어나는경우 발생한다.  
아래는 그 예제이다.

| `key`     | `hashCode()` | `% 3` 결과 (0\~2) | Cache (3대) | `% 4` 결과 (0\~3) | Cache (4대) |
| --------- | ------------ | --------------- | ---------- | --------------- | ---------- |
| `user:1`  | 1223881      | 1               | Cache2     | 1               | Cache2     |
| `user:2`  | 1245239      | 2               | Cache3     | 3               | Cache4     |
| `user:3`  | 1141206      | 0               | Cache1     | 2               | Cache3     |
| `user:4`  | 1245240      | 0               | Cache1     | 0               | Cache1     |
| `user:5`  | 1245241      | 1               | Cache2     | 1               | Cache2     |
| `user:6`  | 1245242      | 2               | Cache3     | 2               | Cache3     |
| `user:7`  | 1245243      | 0               | Cache1     | 3               | Cache4     |
| `user:8`  | 1245244      | 1               | Cache2     | 0               | Cache1     |
| `user:9`  | 1245245      | 2               | Cache3     | 1               | Cache2     |
| `user:10` | 1245246      | 0               | Cache1     | 2               | Cache3     |

이 방법은 서버가 고정됬을때 유용하나 
트래픽 증가로 수평적으로 캐시서버를 늘리거나, 혹은 줄일때 위에 예시처럼 원하는 캐시서버 인덱스가 아닌 잘못된 값을 반환하여 
다른 캐시서버를 히트하는 일이 벌어진다.

안정해시(Consistent Hashing)는 이 문제를 안전하게 해소하는 기법이다. 

---  
## 키이동(Key Migration)

정의 : 기존에 캐시 서버 A에 있던 키가, 서버 추가/삭제로 인해 다른 서버 B로 옮겨지는 현상

**[실제로 어떤 문제가 발생할까?]**  

```
 1. Cache Miss 폭발 (캐시 적중률 급감)
기존 클라이언트는 "user:123"가 Cache1에 있다고 생각하고 요청

그런데 서버가 추가되면서 "user:123"가 Cache3으로 재배치됨

Cache1에는 더 이상 "user:123"가 없음 → Miss 발생

👉 결과적으로 재요청 → DB나 원본 시스템 호출 → 부하 폭증

---

2. 전체 캐시 재구성 (리빌딩)
서버 1대 추가했을 뿐인데, 키들이 모든 서버에 재분배

→ 캐시 초기화와 비슷한 효과

특히 수십 ~ 수백만 개 키를 다 재생성하거나 로드해야 할 수도 있음

예:

기존 키 1,000,000개 중 700,000개가 새로운 서버로 옮겨져야 함 😱

---

🧱 3. 데이터 일관성 문제 (특히 분산 세션, 인증 토큰 등)
로그인 세션: 캐시에 userToken:abc123 저장

서버가 바뀌면서 키가 다른 서버로 이동 → 세션 정보 못 찾음 → 로그아웃됨, 인증 실패

---

💸 4. 리소스 낭비 & 부하 집중
어떤 서버는 캐시 키가 갑자기 몰려 과부하

어떤 서버는 거의 텅 빈 상태
→ 로드밸런싱 실패

```

---
## `% N` 방식에서 키이동 발생 시 영향범위 

```
키 이동 비율 = 1 - (서버 수 변경 전 / 서버 수 변경 후)

[실제 계산]
상황
 > 3대였는데 4대로 변경해야합니다.
 > 전체 키갯수(캐시 서버에 등록된 캐시들의 키 수)가 10만개 정도로 확인됩니다.
  
0.25 = 1 - ( 3 / 4 )  

(정답)
25%가 키 이동 비율로 측정됨

이동해야하는 키 수 = 키 갯수 * 키 이동 비율
25,000 = 100,000 * 0.25


```

---

## 안정해시(Consistent Hashing)
키와 서버를 **원형 해시 링(hash ring)**에 배치하고,
키는 시계방향으로 가장 가까운 서버에 할당한다.
해시 테이블 크기가 조정 될 때 평균적으로 오직 k(키의 갯수)/n(슬롯 갯수)개의 키만 재배치하는 해시 기술이다. 
  
<img width="743" alt="image" src="https://github.com/user-attachments/assets/efe4772c-06ca-4517-942c-47a34cf5f69f" />



| 방식                 | 키 이동 비율                   |
| ------------------ | ------------------------- |
| `% N` 방식           | `1 - (서버 이전 수 / 서버 현재 수)` |
| Consistent Hashing | `1 / (서버 현재 수)`           |


`% N`방식과 키 이동에 비해 엄청나게 효율적인데 
그 차이는 서버수가 1~2 갯수 차이 날 때 보다 큰차이로 서버 대수를 변경할때 더욱 크게 비교된다.
위에서 했던 계산을 아래서 다시 해보자

```

[실제 계산]
상황
 > 3대였는데 4대로 변경해야합니다.

 `% N`방식  > 1 - (3/4) = 0.25
 Consistent Hashing > 1 / 4 = 0.25

둘다 25%의 키들만 키 이동이 벌어지면 됩니다.
이 상황을 좀더 큰 폭으로 변경해 보겠습니다.

상황2
 > 3대였는데 10대로 변경해야합니다.

 `% N`방식  > 1 - (3/10) = 0.7
 Consistent Hashing > 1 / 10 = 0.1

`% N`방식에서는 70퍼센트가 키 이동을 해야하지만 
Consistent Hashing에서는 10퍼센트만 키 이동을 하면 되는걸로 확인 할수 있습니다.


```
---

## Consistent Hashing의 한계

서버 개수가 적고, 해시링 위에 서버가 불균등하게 배치되면
👉 어떤 서버는 키가 몰리고, 어떤 서버는 거의 없음

```
Hash Ring:
     [Cache1: 50]
         ↑
0 ----------------- 360
             ↑
         [Cache2: 310]

```

이런 균등 불균형 문제를 해소하고자 Virtual Node(가상노드)가 나왔다.

---

## 가상노드

| 문제            | 가상 노드 해결 방식                   |
| ------------- | ----------------------------- |
| 키 분포 불균형      | 각 서버가 여러 구간을 담당 → 키가 고르게 분포   |
| 서버 추가 시 편차 발생 | 새로운 가상 노드들이 전체에 퍼져 있으므로 충격 완화 |
| 특정 서버 과부하     | 분산 효과로 완화됨                    |


